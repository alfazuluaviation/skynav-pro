/**
 * Chart Downloader Service
 * Pre-downloads WMS tiles for offline use by fetching tiles for key zoom levels
 * and geographic areas of Brazil.
 * Uses a proxy to avoid CORS issues with DECEA GeoServer.
 * 
 * OPTIMIZED v2: 
 * - Robust tile validation (500+ bytes, image Content-Type)
 * - Automatic retry for failed tiles
 * - Detailed download statistics
 */

import { cacheTile, updateLayerMetadata, getCachedTileCount, isLayerCached } from './tileCache';
import { CHART_LAYERS, ChartLayerId } from '../config/chartLayers';

// WMS URL - Access GeoServer directly (CORS enabled for most requests)
const BASE_WMS_URL = "https://geoaisweb.decea.mil.br/geoserver/wms";

// Multiple CORS proxies for redundancy
const CORS_PROXIES = [
  "https://api.allorigins.win/raw?url=",
  "https://corsproxy.io/?",
  "https://api.codetabs.com/v1/proxy?quest="
];

// Brazil bounding box (approximate)
const BRAZIL_BOUNDS = {
  minLat: -34.0,
  maxLat: 6.0,
  minLng: -74.0,
  maxLng: -34.0
};

// Minimum valid tile size (bytes) - rejects XML errors and empty responses
const MIN_VALID_TILE_SIZE = 500;

export interface DownloadStats {
  totalTiles: number;
  downloadedTiles: number;
  failedTiles: number;
  retriedTiles: number;
}

/**
 * Convert lat/lng to tile coordinates
 */
function latLngToTile(lat: number, lng: number, zoom: number): { x: number; y: number } {
  const n = Math.pow(2, zoom);
  const x = Math.floor((lng + 180) / 360 * n);
  const latRad = lat * Math.PI / 180;
  const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);
  return { x, y };
}

/**
 * Convert tile coordinates to bounding box
 */
function tileToBBox(x: number, y: number, zoom: number): { minLng: number; minLat: number; maxLng: number; maxLat: number } {
  const n = Math.pow(2, zoom);
  const minLng = x / n * 360 - 180;
  const maxLng = (x + 1) / n * 360 - 180;
  
  const minLatRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n)));
  const maxLatRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n)));
  
  const minLat = minLatRad * 180 / Math.PI;
  const maxLat = maxLatRad * 180 / Math.PI;
  
  return { minLng, minLat, maxLng, maxLat };
}

/**
 * Build WMS tile URL (direct to GeoServer)
 * CRITICAL: Must match exactly the URL generated by CachedWMSTileLayer
 * Uses fixed 256px tile size for consistency
 */
function buildWMSTileUrl(layers: string, x: number, y: number, zoom: number): string {
  const bbox = tileToBBox(x, y, zoom);
  // WMS 1.1.1 format: BBOX=minx,miny,maxx,maxy
  const bboxStr = `${bbox.minLng},${bbox.minLat},${bbox.maxLng},${bbox.maxLat}`;
  
  // Fixed 256px tile size for consistency with CachedWMSTileLayer
  const tileSize = 256;
  
  const params = new URLSearchParams({
    service: 'WMS',
    request: 'GetMap',
    layers: layers,
    styles: '',
    format: 'image/png',
    transparent: 'true',
    version: '1.1.1',
    width: tileSize.toString(),
    height: tileSize.toString(),
    srs: 'EPSG:4326',
    bbox: bboxStr
  });

  // Direct GeoServer URL
  return `${BASE_WMS_URL}?${params.toString()}`;
}

/**
 * Build the cache key URL (used for storing/retrieving from IndexedDB)
 * This is the canonical URL format used by CachedWMSTileLayer
 */
function buildCacheKeyUrl(layers: string, x: number, y: number, zoom: number): string {
  // Cache key uses direct URL format for consistency
  return buildWMSTileUrl(layers, x, y, zoom);
}

/**
 * Generate all tile coordinates for a zoom level within Brazil bounds
 */
function getTilesForZoom(zoom: number): Array<{ x: number; y: number }> {
  const minTile = latLngToTile(BRAZIL_BOUNDS.maxLat, BRAZIL_BOUNDS.minLng, zoom);
  const maxTile = latLngToTile(BRAZIL_BOUNDS.minLat, BRAZIL_BOUNDS.maxLng, zoom);
  
  const tiles: Array<{ x: number; y: number }> = [];
  
  for (let x = minTile.x; x <= maxTile.x; x++) {
    for (let y = minTile.y; y <= maxTile.y; y++) {
      tiles.push({ x, y });
    }
  }
  
  return tiles;
}

interface TileInfo {
  directUrl: string;
  cacheKey: string;
  zoom: number;
  x: number;
  y: number;
}

/**
 * Download a single tile with retry and CORS proxy fallback
 * IMPROVED: Better validation and proxy rotation
 * @param directUrl - Direct GeoServer URL
 * @param cacheKey - URL to use as cache key (for consistency with CachedWMSTileLayer)
 * @param layerId - Layer ID for logging
 * @param proxyStartIndex - Which proxy to try first (for rotation)
 */
async function downloadTile(
  directUrl: string, 
  cacheKey: string, 
  layerId: string, 
  proxyStartIndex: number = 0
): Promise<{ success: boolean; fromProxy: number }> {
  
  // Helper to validate response
  const validateResponse = async (response: Response): Promise<Blob | null> => {
    if (!response.ok) return null;
    
    const contentType = response.headers.get('content-type') || '';
    
    // Reject XML/text responses (GeoServer errors)
    if (contentType.includes('xml') || contentType.includes('text/html')) {
      return null;
    }
    
    const blob = await response.blob();
    
    // Validate: must be an image with reasonable size
    if (!blob.type.startsWith('image/')) return null;
    if (blob.size < MIN_VALID_TILE_SIZE) return null;
    
    return blob;
  };

  // Try direct access first
  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 8000);
    
    const response = await fetch(directUrl, {
      mode: 'cors',
      credentials: 'omit',
      signal: controller.signal,
      headers: { 'Accept': 'image/png,image/*' }
    });
    
    clearTimeout(timeout);
    
    const blob = await validateResponse(response);
    if (blob) {
      await cacheTile(cacheKey, blob, layerId);
      return { success: true, fromProxy: -1 };
    }
  } catch (error) {
    // CORS or network error - try proxies
  }

  // Try proxies in rotation order
  for (let i = 0; i < CORS_PROXIES.length; i++) {
    const proxyIndex = (proxyStartIndex + i) % CORS_PROXIES.length;
    const proxyUrl = `${CORS_PROXIES[proxyIndex]}${encodeURIComponent(directUrl)}`;
    
    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 10000);
      
      const response = await fetch(proxyUrl, {
        mode: 'cors',
        credentials: 'omit',
        signal: controller.signal
      });
      
      clearTimeout(timeout);
      
      const blob = await validateResponse(response);
      if (blob) {
        await cacheTile(cacheKey, blob, layerId);
        return { success: true, fromProxy: proxyIndex };
      }
    } catch (error) {
      // Continue to next proxy
    }
  }

  return { success: false, fromProxy: -1 };
}

/**
 * Download all tiles for a chart layer with retry support
 * OPTIMIZED: Better batching, progress reporting, and retry logic
 */
export async function downloadChartLayer(
  layerId: string,
  onProgress?: (progress: number, stats?: DownloadStats) => void
): Promise<boolean> {
  const config = CHART_LAYERS[layerId as ChartLayerId];
  if (!config) {
    console.error('[ChartDownloader] Unknown layer:', layerId);
    return false;
  }

  const zoomLevels = config.zoomLevels;
  const layersString = config.layers;

  // Calculate total tiles
  let allTiles: TileInfo[] = [];
  
  for (const zoom of zoomLevels) {
    const tiles = getTilesForZoom(zoom);
    for (const tile of tiles) {
      const directUrl = buildWMSTileUrl(layersString, tile.x, tile.y, zoom);
      const cacheKey = buildCacheKeyUrl(layersString, tile.x, tile.y, zoom);
      allTiles.push({ directUrl, cacheKey, zoom, ...tile });
    }
  }

  const totalTiles = allTiles.length;
  let processedTiles = 0;
  let downloadedTiles = 0;
  let failedTiles: TileInfo[] = [];
  let lastReportedProgress = -1;
  let preferredProxy = 0;

  console.log(`[ChartDownloader] Starting ${layerId}: ${totalTiles} tiles, zooms ${zoomLevels.join(',')}`);

  // Report initial progress
  onProgress?.(0, { totalTiles, downloadedTiles: 0, failedTiles: 0, retriedTiles: 0 });

  // Update metadata to downloading
  await updateLayerMetadata({
    layerId,
    totalTiles,
    downloadedTiles: 0,
    lastUpdated: Date.now(),
    status: 'downloading'
  });

  // Detect iOS/iPad for batch size
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  
  // Batch sizes optimized for stability
  const batchSize = isIOS ? 4 : 8;
  
  console.log(`[ChartDownloader] Device: ${isIOS ? 'iOS' : 'Desktop'}, batchSize=${batchSize}`);
  
  // First pass: download all tiles
  for (let i = 0; i < allTiles.length; i += batchSize) {
    const batch = allTiles.slice(i, i + batchSize);
    
    await Promise.all(
      batch.map(async (tile) => {
        const result = await downloadTile(tile.directUrl, tile.cacheKey, layerId, preferredProxy);
        
        if (result.success) {
          downloadedTiles++;
          // Update preferred proxy if one worked
          if (result.fromProxy >= 0) {
            preferredProxy = result.fromProxy;
          }
        } else {
          failedTiles.push(tile);
        }
        processedTiles++;
        
        // Report progress (throttled)
        const progress = Math.round((processedTiles / totalTiles) * 100);
        if (progress !== lastReportedProgress && progress % 2 === 0) {
          lastReportedProgress = progress;
          onProgress?.(progress, { 
            totalTiles, 
            downloadedTiles, 
            failedTiles: failedTiles.length,
            retriedTiles: 0 
          });
        }
      })
    );

    // Short delay between batches
    if (i + batchSize < allTiles.length) {
      await new Promise(resolve => setTimeout(resolve, 30));
    }
  }

  // Retry pass: try failed tiles again (max 2 retries)
  let retriedTiles = 0;
  if (failedTiles.length > 0 && failedTiles.length < totalTiles * 0.5) {
    console.log(`[ChartDownloader] Retrying ${failedTiles.length} failed tiles...`);
    
    const retryBatchSize = Math.max(2, Math.floor(batchSize / 2));
    let stillFailed: TileInfo[] = [];
    
    for (let retry = 0; retry < 2; retry++) {
      if (failedTiles.length === 0) break;
      
      // Wait before retry (exponential backoff)
      await new Promise(resolve => setTimeout(resolve, 500 * Math.pow(2, retry)));
      
      const tilesToRetry = [...failedTiles];
      failedTiles = [];
      
      for (let i = 0; i < tilesToRetry.length; i += retryBatchSize) {
        const batch = tilesToRetry.slice(i, i + retryBatchSize);
        
        await Promise.all(
          batch.map(async (tile) => {
            // Try different proxy on retry
            const result = await downloadTile(
              tile.directUrl, 
              tile.cacheKey, 
              layerId, 
              (preferredProxy + retry + 1) % CORS_PROXIES.length
            );
            
            if (result.success) {
              downloadedTiles++;
              retriedTiles++;
              if (result.fromProxy >= 0) {
                preferredProxy = result.fromProxy;
              }
            } else {
              failedTiles.push(tile);
            }
          })
        );
        
        // Update progress during retry
        const progress = Math.min(99, 90 + Math.round((i / tilesToRetry.length) * 10));
        onProgress?.(progress, { 
          totalTiles, 
          downloadedTiles, 
          failedTiles: failedTiles.length,
          retriedTiles 
        });
        
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
  }

  // Final progress update
  onProgress?.(100, { 
    totalTiles, 
    downloadedTiles, 
    failedTiles: failedTiles.length,
    retriedTiles 
  });

  const successRate = ((downloadedTiles / totalTiles) * 100).toFixed(1);
  console.log(`[ChartDownloader] Complete ${layerId}: ${downloadedTiles}/${totalTiles} tiles (${successRate}%), ${failedTiles.length} failed, ${retriedTiles} retried`);

  // Update metadata - mark as complete if success rate > 90%
  const isComplete = downloadedTiles >= totalTiles * 0.9;
  await updateLayerMetadata({
    layerId,
    totalTiles,
    downloadedTiles,
    lastUpdated: Date.now(),
    status: isComplete ? 'complete' : 'error'
  });

  return isComplete;
}

/**
 * Check if a layer is available offline
 */
export async function isLayerAvailableOffline(layerId: string): Promise<boolean> {
  return isLayerCached(layerId);
}

/**
 * Get download status for a layer
 */
export async function getLayerDownloadStatus(layerId: string): Promise<{
  isDownloaded: boolean;
  tileCount: number;
}> {
  const isDownloaded = await isLayerCached(layerId);
  const tileCount = await getCachedTileCount(layerId);
  
  return { isDownloaded, tileCount };
}
