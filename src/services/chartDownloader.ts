/**
 * Chart Downloader Service
 * Pre-downloads WMS tiles for offline use by fetching tiles for key zoom levels
 * and geographic areas of Brazil.
 * Uses a proxy to avoid CORS issues with DECEA GeoServer.
 */

import { cacheTile, updateLayerMetadata, getCachedTileCount, isLayerCached } from './tileCache';
import { CHART_LAYERS, ChartLayerId } from '../config/chartLayers';

// Supabase edge function URL for WMS proxy
const SUPABASE_URL = "https://gongoqjjpwphhttumdjm.supabase.co";
const WMS_PROXY_URL = `${SUPABASE_URL}/functions/v1/proxy-wms`;

// Brazil bounding box (approximate)
const BRAZIL_BOUNDS = {
  minLat: -34.0,
  maxLat: 6.0,
  minLng: -74.0,
  maxLng: -34.0
};

/**
 * Convert lat/lng to tile coordinates
 */
function latLngToTile(lat: number, lng: number, zoom: number): { x: number; y: number } {
  const n = Math.pow(2, zoom);
  const x = Math.floor((lng + 180) / 360 * n);
  const latRad = lat * Math.PI / 180;
  const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);
  return { x, y };
}

/**
 * Convert tile coordinates to bounding box
 */
function tileToBBox(x: number, y: number, zoom: number): { minLng: number; minLat: number; maxLng: number; maxLat: number } {
  const n = Math.pow(2, zoom);
  const minLng = x / n * 360 - 180;
  const maxLng = (x + 1) / n * 360 - 180;
  
  const minLatRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n)));
  const maxLatRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n)));
  
  const minLat = minLatRad * 180 / Math.PI;
  const maxLat = maxLatRad * 180 / Math.PI;
  
  return { minLng, minLat, maxLng, maxLat };
}

/**
 * Build WMS tile URL using proxy to avoid CORS
 * CRITICAL: Must match exactly the URL generated by CachedWMSTileLayer
 * Uses fixed 256px tile size for consistency
 */
function buildWMSTileUrl(layers: string, x: number, y: number, zoom: number): string {
  const bbox = tileToBBox(x, y, zoom);
  // WMS 1.1.1 format: BBOX=minx,miny,maxx,maxy
  const bboxStr = `${bbox.minLng},${bbox.minLat},${bbox.maxLng},${bbox.maxLat}`;
  
  // Fixed 256px tile size for consistency with CachedWMSTileLayer
  const tileSize = 256;
  
  const params = new URLSearchParams({
    service: 'WMS',
    request: 'GetMap',
    layers: layers,
    styles: '',
    format: 'image/png',
    transparent: 'true',
    version: '1.1.1',
    width: tileSize.toString(),
    height: tileSize.toString(),
    srs: 'EPSG:4326',
    bbox: bboxStr
  });

  // Use proxy to avoid CORS issues
  return `${WMS_PROXY_URL}?${params.toString()}`;
}

/**
 * Generate all tile coordinates for a zoom level within Brazil bounds
 */
function getTilesForZoom(zoom: number): Array<{ x: number; y: number }> {
  const minTile = latLngToTile(BRAZIL_BOUNDS.maxLat, BRAZIL_BOUNDS.minLng, zoom);
  const maxTile = latLngToTile(BRAZIL_BOUNDS.minLat, BRAZIL_BOUNDS.maxLng, zoom);
  
  const tiles: Array<{ x: number; y: number }> = [];
  
  for (let x = minTile.x; x <= maxTile.x; x++) {
    for (let y = minTile.y; y <= maxTile.y; y++) {
      tiles.push({ x, y });
    }
  }
  
  return tiles;
}

/**
 * Download a single tile with retry
 */
async function downloadTile(url: string, layerId: string, retries: number = 3): Promise<boolean> {
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 20000); // 20s timeout (increased)
      
      const response = await fetch(url, {
        mode: 'cors',
        credentials: 'omit',
        signal: controller.signal,
        headers: {
          'Accept': 'image/png,image/*'
        }
      });
      
      clearTimeout(timeout);

      if (!response.ok) {
        console.warn(`[ChartDownloader] HTTP ${response.status} for tile, attempt ${attempt + 1}/${retries + 1}`);
        if (attempt < retries) {
          // Exponential backoff: 500ms, 1s, 2s
          await new Promise(r => setTimeout(r, 500 * Math.pow(2, attempt)));
          continue;
        }
        return false;
      }

      const blob = await response.blob();
      const contentType = response.headers.get('content-type') || blob.type;
      
      // Validate: must be an image with reasonable size (at least 2KB for a valid 512x512 tile)
      // Empty/error tiles from WMS are typically very small (< 2KB) or not images
      const isValidImage = contentType.startsWith('image/') && blob.size > 2000;
      
      if (isValidImage) {
        await cacheTile(url, blob, layerId);
        return true;
      } else {
        // Don't cache small/invalid responses - they might be errors
        // Just skip without caching - the tile will load from network next time
        if (blob.size < 2000) {
          console.debug(`[ChartDownloader] Skipping small tile (${blob.size} bytes) - likely empty area`);
        } else {
          console.warn(`[ChartDownloader] Invalid content-type: ${contentType}`);
        }
        return true; // Count as processed but don't cache
      }
    } catch (error) {
      if (attempt < retries) {
        // Exponential backoff
        await new Promise(r => setTimeout(r, 500 * Math.pow(2, attempt)));
        continue;
      }
      console.warn('[ChartDownloader] Failed to download tile after retries:', (error as Error).message);
      return false;
    }
  }
  return false;
}

/**
 * Download all tiles for a chart layer
 */
export async function downloadChartLayer(
  layerId: string,
  onProgress?: (progress: number) => void
): Promise<boolean> {
  const config = CHART_LAYERS[layerId as ChartLayerId];
  if (!config) {
    console.error('Unknown layer:', layerId);
    return false;
  }

  const zoomLevels = config.zoomLevels;
  const layersString = config.layers; // Already a string, ready to use

  // Calculate total tiles (using 256px tiles for consistency)
  let allTiles: Array<{ url: string; zoom: number; x: number; y: number }> = [];
  
  for (const zoom of zoomLevels) {
    const tiles = getTilesForZoom(zoom);
    for (const tile of tiles) {
      const url = buildWMSTileUrl(layersString, tile.x, tile.y, zoom);
      allTiles.push({ url, zoom, ...tile });
    }
  }

  const totalTiles = allTiles.length;
  let processedTiles = 0;
  let downloadedTiles = 0;

  console.log(`Starting download of ${layerId}: ${totalTiles} tiles across zoom levels ${zoomLevels.join(', ')}`);
  console.log(`Using layers: ${layersString}`);

  // Report initial progress immediately
  onProgress?.(0);

  // Update metadata to downloading
  await updateLayerMetadata({
    layerId,
    totalTiles,
    downloadedTiles: 0,
    lastUpdated: Date.now(),
    status: 'downloading'
  });

  // Detect iOS/iPad - use smaller batch size to avoid connection issues
  // Also reduce batch size generally to avoid overwhelming the proxy/GeoServer
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  // Reduced batch sizes: iOS=2, Desktop=5 (was 3 and 10)
  const batchSize = isIOS ? 2 : 5;
  
  console.log(`[ChartDownloader] Using batchSize=${batchSize}, isIOS=${isIOS}, totalTiles=${totalTiles}`);
  
  for (let i = 0; i < allTiles.length; i += batchSize) {
    const batch = allTiles.slice(i, i + batchSize);
    
    await Promise.all(
      batch.map(async (tile) => {
        const success = await downloadTile(tile.url, layerId);
        if (success) {
          downloadedTiles++;
        }
        processedTiles++;
        
        // Report progress based on processed tiles (not just successful)
        // This ensures progress always moves forward
        const progress = Math.round((processedTiles / totalTiles) * 100);
        onProgress?.(progress);
      })
    );

    // Delay between batches to avoid rate limiting (100ms)
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  console.log(`Download complete for ${layerId}: ${downloadedTiles}/${totalTiles} tiles cached`);

  // Update metadata to complete
  await updateLayerMetadata({
    layerId,
    totalTiles,
    downloadedTiles,
    lastUpdated: Date.now(),
    status: 'complete'
  });

  return true;
}

/**
 * Check if a layer is available offline
 */
export async function isLayerAvailableOffline(layerId: string): Promise<boolean> {
  return isLayerCached(layerId);
}

/**
 * Get download status for a layer
 */
export async function getLayerDownloadStatus(layerId: string): Promise<{
  isDownloaded: boolean;
  tileCount: number;
}> {
  const isDownloaded = await isLayerCached(layerId);
  const tileCount = await getCachedTileCount(layerId);
  
  return { isDownloaded, tileCount };
}
