/**
 * Chart Downloader Service
 * Pre-downloads WMS tiles for offline use by fetching tiles for key zoom levels
 * and geographic areas of Brazil.
 * Uses a proxy to avoid CORS issues with DECEA GeoServer.
 */

import { cacheTile, updateLayerMetadata, getCachedTileCount, isLayerCached } from './tileCache';
import { CHART_LAYERS, ChartLayerId } from '../config/chartLayers';

// Supabase edge function URL for WMS proxy
const SUPABASE_URL = "https://gongoqjjpwphhttumdjm.supabase.co";
const WMS_PROXY_URL = `${SUPABASE_URL}/functions/v1/proxy-wms`;

// Brazil bounding box (approximate)
const BRAZIL_BOUNDS = {
  minLat: -34.0,
  maxLat: 6.0,
  minLng: -74.0,
  maxLng: -34.0
};

/**
 * Convert lat/lng to tile coordinates
 */
function latLngToTile(lat: number, lng: number, zoom: number): { x: number; y: number } {
  const n = Math.pow(2, zoom);
  const x = Math.floor((lng + 180) / 360 * n);
  const latRad = lat * Math.PI / 180;
  const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);
  return { x, y };
}

/**
 * Convert tile coordinates to bounding box
 */
function tileToBBox(x: number, y: number, zoom: number): { minLng: number; minLat: number; maxLng: number; maxLat: number } {
  const n = Math.pow(2, zoom);
  const minLng = x / n * 360 - 180;
  const maxLng = (x + 1) / n * 360 - 180;
  
  const minLatRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n)));
  const maxLatRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n)));
  
  const minLat = minLatRad * 180 / Math.PI;
  const maxLat = maxLatRad * 180 / Math.PI;
  
  return { minLng, minLat, maxLng, maxLat };
}

/**
 * Build WMS tile URL using proxy to avoid CORS
 * CRITICAL: Must match exactly the URL generated by CachedWMSTileLayer
 * Uses fixed 256px tile size for consistency
 */
function buildWMSTileUrl(layers: string, x: number, y: number, zoom: number): string {
  const bbox = tileToBBox(x, y, zoom);
  // WMS 1.1.1 format: BBOX=minx,miny,maxx,maxy
  const bboxStr = `${bbox.minLng},${bbox.minLat},${bbox.maxLng},${bbox.maxLat}`;
  
  // Fixed 256px tile size for consistency with CachedWMSTileLayer
  const tileSize = 256;
  
  const params = new URLSearchParams({
    service: 'WMS',
    request: 'GetMap',
    layers: layers,
    styles: '',
    format: 'image/png',
    transparent: 'true',
    version: '1.1.1',
    width: tileSize.toString(),
    height: tileSize.toString(),
    srs: 'EPSG:4326',
    bbox: bboxStr
  });

  // Use proxy to avoid CORS issues
  return `${WMS_PROXY_URL}?${params.toString()}`;
}

/**
 * Generate all tile coordinates for a zoom level within Brazil bounds
 */
function getTilesForZoom(zoom: number): Array<{ x: number; y: number }> {
  const minTile = latLngToTile(BRAZIL_BOUNDS.maxLat, BRAZIL_BOUNDS.minLng, zoom);
  const maxTile = latLngToTile(BRAZIL_BOUNDS.minLat, BRAZIL_BOUNDS.maxLng, zoom);
  
  const tiles: Array<{ x: number; y: number }> = [];
  
  for (let x = minTile.x; x <= maxTile.x; x++) {
    for (let y = minTile.y; y <= maxTile.y; y++) {
      tiles.push({ x, y });
    }
  }
  
  return tiles;
}

/**
 * Download a single tile with retry
 * More aggressive timeout and retry strategy for mobile
 */
async function downloadTile(url: string, layerId: string, retries: number = 2): Promise<boolean> {
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      const controller = new AbortController();
      // Shorter timeout (15s) to fail fast and retry
      const timeout = setTimeout(() => controller.abort(), 15000);
      
      const response = await fetch(url, {
        mode: 'cors',
        credentials: 'omit',
        signal: controller.signal,
        headers: {
          'Accept': 'image/png,image/*'
        }
      });
      
      clearTimeout(timeout);

      if (!response.ok) {
        if (attempt < retries) {
          await new Promise(r => setTimeout(r, 300 * Math.pow(2, attempt)));
          continue;
        }
        return false;
      }

      const blob = await response.blob();
      const contentType = response.headers.get('content-type') || blob.type;
      
      // Validate: must be an image with reasonable size
      // Reduce threshold to 500 bytes since some tiles are naturally small
      const isValidImage = contentType.startsWith('image/') && blob.size > 500;
      
      if (isValidImage) {
        await cacheTile(url, blob, layerId);
        return true;
      } else {
        // Skip empty/error tiles without caching
        return true; // Count as processed but don't cache
      }
    } catch (error) {
      if (attempt < retries) {
        await new Promise(r => setTimeout(r, 300 * Math.pow(2, attempt)));
        continue;
      }
      // Silent fail - don't spam console on mobile
      return false;
    }
  }
  return false;
}

/**
 * Download all tiles for a chart layer
 * OPTIMIZED: Better batching and progress reporting for mobile
 */
export async function downloadChartLayer(
  layerId: string,
  onProgress?: (progress: number) => void
): Promise<boolean> {
  const config = CHART_LAYERS[layerId as ChartLayerId];
  if (!config) {
    console.error('[ChartDownloader] Unknown layer:', layerId);
    return false;
  }

  const zoomLevels = config.zoomLevels;
  const layersString = config.layers;

  // Calculate total tiles
  let allTiles: Array<{ url: string; zoom: number; x: number; y: number }> = [];
  
  for (const zoom of zoomLevels) {
    const tiles = getTilesForZoom(zoom);
    for (const tile of tiles) {
      const url = buildWMSTileUrl(layersString, tile.x, tile.y, zoom);
      allTiles.push({ url, zoom, ...tile });
    }
  }

  const totalTiles = allTiles.length;
  let processedTiles = 0;
  let downloadedTiles = 0;
  let lastReportedProgress = -1;

  console.log(`[ChartDownloader] Starting ${layerId}: ${totalTiles} tiles, zooms ${zoomLevels.join(',')}`);

  // Report initial progress
  onProgress?.(0);

  // Update metadata to downloading
  await updateLayerMetadata({
    layerId,
    totalTiles,
    downloadedTiles: 0,
    lastUpdated: Date.now(),
    status: 'downloading'
  });

  // Detect iOS/iPad for batch size
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  
  // Increased batch sizes since we reduced total tile count
  const batchSize = isIOS ? 4 : 10;
  
  console.log(`[ChartDownloader] Device: ${isIOS ? 'iOS' : 'Desktop'}, batchSize=${batchSize}`);
  
  for (let i = 0; i < allTiles.length; i += batchSize) {
    const batch = allTiles.slice(i, i + batchSize);
    
    await Promise.all(
      batch.map(async (tile) => {
        const success = await downloadTile(tile.url, layerId);
        if (success) {
          downloadedTiles++;
        }
        processedTiles++;
        
        // Report progress (throttled to avoid too many updates)
        const progress = Math.round((processedTiles / totalTiles) * 100);
        if (progress !== lastReportedProgress && progress % 2 === 0) {
          lastReportedProgress = progress;
          onProgress?.(progress);
        }
      })
    );

    // Short delay between batches
    if (i + batchSize < allTiles.length) {
      await new Promise(resolve => setTimeout(resolve, 50));
    }
  }

  // Final progress update
  onProgress?.(100);

  console.log(`[ChartDownloader] Complete ${layerId}: ${downloadedTiles}/${totalTiles} tiles cached`);

  // Update metadata to complete
  await updateLayerMetadata({
    layerId,
    totalTiles,
    downloadedTiles,
    lastUpdated: Date.now(),
    status: 'complete'
  });

  return true;
}

/**
 * Check if a layer is available offline
 */
export async function isLayerAvailableOffline(layerId: string): Promise<boolean> {
  return isLayerCached(layerId);
}

/**
 * Get download status for a layer
 */
export async function getLayerDownloadStatus(layerId: string): Promise<{
  isDownloaded: boolean;
  tileCount: number;
}> {
  const isDownloaded = await isLayerCached(layerId);
  const tileCount = await getCachedTileCount(layerId);
  
  return { isDownloaded, tileCount };
}
