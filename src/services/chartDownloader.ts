/**
 * Chart Downloader Service
 * Pre-downloads WMS tiles for offline use by fetching tiles for key zoom levels
 * and geographic areas of Brazil.
 * Uses a proxy to avoid CORS issues with DECEA GeoServer.
 */

import { cacheTile, updateLayerMetadata, getCachedTileCount, isLayerCached } from './tileCache';
import { CHART_LAYERS, ChartLayerId } from '../config/chartLayers';

// WMS URL - Access GeoServer directly (CORS enabled for most requests)
// Fallback to public proxy if direct access fails
const BASE_WMS_URL = "https://geoaisweb.decea.mil.br/geoserver/wms";

// Simple CORS proxy fallback - only used if direct request fails
const CORS_PROXY_URL = "https://api.allorigins.win/raw?url=";

// Brazil bounding box (approximate)
const BRAZIL_BOUNDS = {
  minLat: -34.0,
  maxLat: 6.0,
  minLng: -74.0,
  maxLng: -34.0
};

/**
 * Convert lat/lng to tile coordinates
 */
function latLngToTile(lat: number, lng: number, zoom: number): { x: number; y: number } {
  const n = Math.pow(2, zoom);
  const x = Math.floor((lng + 180) / 360 * n);
  const latRad = lat * Math.PI / 180;
  const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);
  return { x, y };
}

/**
 * Convert tile coordinates to bounding box
 */
function tileToBBox(x: number, y: number, zoom: number): { minLng: number; minLat: number; maxLng: number; maxLat: number } {
  const n = Math.pow(2, zoom);
  const minLng = x / n * 360 - 180;
  const maxLng = (x + 1) / n * 360 - 180;
  
  const minLatRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n)));
  const maxLatRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n)));
  
  const minLat = minLatRad * 180 / Math.PI;
  const maxLat = maxLatRad * 180 / Math.PI;
  
  return { minLng, minLat, maxLng, maxLat };
}

/**
 * Build WMS tile URL (direct to GeoServer)
 * CRITICAL: Must match exactly the URL generated by CachedWMSTileLayer
 * Uses fixed 256px tile size for consistency
 */
function buildWMSTileUrl(layers: string, x: number, y: number, zoom: number): string {
  const bbox = tileToBBox(x, y, zoom);
  // WMS 1.1.1 format: BBOX=minx,miny,maxx,maxy
  const bboxStr = `${bbox.minLng},${bbox.minLat},${bbox.maxLng},${bbox.maxLat}`;
  
  // Fixed 256px tile size for consistency with CachedWMSTileLayer
  const tileSize = 256;
  
  const params = new URLSearchParams({
    service: 'WMS',
    request: 'GetMap',
    layers: layers,
    styles: '',
    format: 'image/png',
    transparent: 'true',
    version: '1.1.1',
    width: tileSize.toString(),
    height: tileSize.toString(),
    srs: 'EPSG:4326',
    bbox: bboxStr
  });

  // Direct GeoServer URL
  return `${BASE_WMS_URL}?${params.toString()}`;
}

/**
 * Build the cache key URL (used for storing/retrieving from IndexedDB)
 * This is the canonical URL format used by CachedWMSTileLayer
 */
function buildCacheKeyUrl(layers: string, x: number, y: number, zoom: number): string {
  // Cache key uses direct URL format for consistency
  return buildWMSTileUrl(layers, x, y, zoom);
}

/**
 * Generate all tile coordinates for a zoom level within Brazil bounds
 */
function getTilesForZoom(zoom: number): Array<{ x: number; y: number }> {
  const minTile = latLngToTile(BRAZIL_BOUNDS.maxLat, BRAZIL_BOUNDS.minLng, zoom);
  const maxTile = latLngToTile(BRAZIL_BOUNDS.minLat, BRAZIL_BOUNDS.maxLng, zoom);
  
  const tiles: Array<{ x: number; y: number }> = [];
  
  for (let x = minTile.x; x <= maxTile.x; x++) {
    for (let y = minTile.y; y <= maxTile.y; y++) {
      tiles.push({ x, y });
    }
  }
  
  return tiles;
}

/**
 * Download a single tile with retry and CORS proxy fallback
 * Tries direct access first, falls back to public CORS proxy
 * @param directUrl - Direct GeoServer URL
 * @param cacheKey - URL to use as cache key (for consistency with CachedWMSTileLayer)
 * @param layerId - Layer ID for logging
 * @param retries - Number of retries per method
 */
async function downloadTile(directUrl: string, cacheKey: string, layerId: string, retries: number = 2): Promise<boolean> {
  // Try direct access first (some browsers/GeoServer configs allow it)
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 12000);
      
      const response = await fetch(directUrl, {
        mode: 'cors',
        credentials: 'omit',
        signal: controller.signal,
        headers: {
          'Accept': 'image/png,image/*'
        }
      });
      
      clearTimeout(timeout);

      if (response.ok) {
        const blob = await response.blob();
        const contentType = response.headers.get('content-type') || blob.type;
        
        // Validate: must be an image with reasonable size
        if (contentType.startsWith('image/') && blob.size > 100) {
          // Use cacheKey for storage (matches what CachedWMSTileLayer will look up)
          await cacheTile(cacheKey, blob, layerId);
          return true;
        }
        // Empty or error tile - count as processed
        return true;
      }
    } catch (error) {
      // CORS or network error - try fallback
      if (attempt === retries) break;
      await new Promise(r => setTimeout(r, 200 * Math.pow(2, attempt)));
    }
  }

  // Fallback: Try CORS proxy
  const proxyUrl = `${CORS_PROXY_URL}${encodeURIComponent(directUrl)}`;
  
  for (let attempt = 0; attempt <= 1; attempt++) {
    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 15000);
      
      const response = await fetch(proxyUrl, {
        mode: 'cors',
        credentials: 'omit',
        signal: controller.signal
      });
      
      clearTimeout(timeout);

      if (response.ok) {
        const blob = await response.blob();
        const contentType = response.headers.get('content-type') || blob.type;
        
        if (contentType.startsWith('image/') && blob.size > 100) {
          await cacheTile(cacheKey, blob, layerId);
          return true;
        }
        return true;
      }
    } catch (error) {
      if (attempt === 1) return false;
      await new Promise(r => setTimeout(r, 500));
    }
  }

  return false;
}

/**
 * Download all tiles for a chart layer
 * OPTIMIZED: Better batching and progress reporting for mobile
 */
export async function downloadChartLayer(
  layerId: string,
  onProgress?: (progress: number) => void
): Promise<boolean> {
  const config = CHART_LAYERS[layerId as ChartLayerId];
  if (!config) {
    console.error('[ChartDownloader] Unknown layer:', layerId);
    return false;
  }

  const zoomLevels = config.zoomLevels;
  const layersString = config.layers;

  // Calculate total tiles
  let allTiles: Array<{ directUrl: string; cacheKey: string; zoom: number; x: number; y: number }> = [];
  
  for (const zoom of zoomLevels) {
    const tiles = getTilesForZoom(zoom);
    for (const tile of tiles) {
      const directUrl = buildWMSTileUrl(layersString, tile.x, tile.y, zoom);
      const cacheKey = buildCacheKeyUrl(layersString, tile.x, tile.y, zoom);
      allTiles.push({ directUrl, cacheKey, zoom, ...tile });
    }
  }

  const totalTiles = allTiles.length;
  let processedTiles = 0;
  let downloadedTiles = 0;
  let lastReportedProgress = -1;

  console.log(`[ChartDownloader] Starting ${layerId}: ${totalTiles} tiles, zooms ${zoomLevels.join(',')}`);

  // Report initial progress
  onProgress?.(0);

  // Update metadata to downloading
  await updateLayerMetadata({
    layerId,
    totalTiles,
    downloadedTiles: 0,
    lastUpdated: Date.now(),
    status: 'downloading'
  });

  // Detect iOS/iPad for batch size
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  
  // Increased batch sizes since we reduced total tile count
  const batchSize = isIOS ? 4 : 10;
  
  console.log(`[ChartDownloader] Device: ${isIOS ? 'iOS' : 'Desktop'}, batchSize=${batchSize}`);
  
  for (let i = 0; i < allTiles.length; i += batchSize) {
    const batch = allTiles.slice(i, i + batchSize);
    
    await Promise.all(
      batch.map(async (tile) => {
        const success = await downloadTile(tile.directUrl, tile.cacheKey, layerId);
        if (success) {
          downloadedTiles++;
        }
        processedTiles++;
        
        // Report progress (throttled to avoid too many updates)
        const progress = Math.round((processedTiles / totalTiles) * 100);
        if (progress !== lastReportedProgress && progress % 2 === 0) {
          lastReportedProgress = progress;
          onProgress?.(progress);
        }
      })
    );

    // Short delay between batches
    if (i + batchSize < allTiles.length) {
      await new Promise(resolve => setTimeout(resolve, 50));
    }
  }

  // Final progress update
  onProgress?.(100);

  console.log(`[ChartDownloader] Complete ${layerId}: ${downloadedTiles}/${totalTiles} tiles cached`);

  // Update metadata to complete
  await updateLayerMetadata({
    layerId,
    totalTiles,
    downloadedTiles,
    lastUpdated: Date.now(),
    status: 'complete'
  });

  return true;
}

/**
 * Check if a layer is available offline
 */
export async function isLayerAvailableOffline(layerId: string): Promise<boolean> {
  return isLayerCached(layerId);
}

/**
 * Get download status for a layer
 */
export async function getLayerDownloadStatus(layerId: string): Promise<{
  isDownloaded: boolean;
  tileCount: number;
}> {
  const isDownloaded = await isLayerCached(layerId);
  const tileCount = await getCachedTileCount(layerId);
  
  return { isDownloaded, tileCount };
}
